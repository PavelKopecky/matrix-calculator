= Maticová kalkulačka
Autor: Pavel Kopecký, kopecp14

== Zadání

Vaším úkolem je vytvořit kalkulačku pro práci s maticemi. Jednotlivé matice a výsledky operací je možné ukládat do proměnných a tyto proměnné následně využívat v dalších výpočtech.

=== Kalkulačka musí implementovat následující funkcionality:

Práce s maticemi libovolné velikosti (především načtení a vypsání proměnných).

Základní operace: sčítání, odčítání, násobení a transpozice.

Sloučení matic (př. matice 3x3 sloučeno s 3x3 ⇒ matice 6x3) a oříznutí (př. matice 6x6 oříznuta na 3x3 v offsetu 0x0 ⇒ levá polovina matice 3x3).

Výpočet inverzní matice pro čtvercové matice.

Funkce pro výpočet determinantu, určení hodnosti a provedení Gaussovy eliminační metody.

Stav kalkulačky (tedy její proměnné) je možné uložit do souboru v textově čitelné formě. Stejně tak je potom možné tento stav ze souboru obnovit.

Uložení v rámci proměnných (a souboru) musí být paměťově efektivní. Při ukládání proměnné do paměti se musí určit typ dané matice. Rozlišujte alespoň řídké matice (obsahují především nulové hodnoty, př. jednotková matice) a husté matice (opak řídkých, př. hodnota prvku v matici je rovna jeho součtu jeho indexů) a podle toho určete efektivní reprezentaci.

=== Dále aplikace musí zpracovávat výrazy dle jednoho z následujících principů:

Základní operace (alespoň sčítání, odčítání a násobení) musí jít vnořovat pomocí závorek (př. (Z = [[1, 0], [0, 1]] + X) * Y). Funkce a složitější operace mohou fungovat formou individuálních příkazů bez dalšího skládání (př. A = GAUSS X).
Pro zapisování výrazů využijte prefixový (nebo postfixový) zápis, mají tu výhodu, že nevyžadují závorky a snáze se zpracovávají. V tomto případě však veškeré operace a funkce musí jít zapsat v jednom výrazu (př. A = GAUSS MUL Y ADD [[1, 0], [0, 1]] X).

=== Ukázka běhu programu: (nezávazný příklad)

IMPORT memory.matx
X = DET [[1, 7], [3, 2]]
SCAN Y
// input from user …
Z = X * (Y + [[1, 0], [0, 1]])
A = GEM Z
PRINT A
EXPORT memory.matx

=== Kde lze využít polymorfismus? (doporučené)

reprezentace matice: jednotková, řídká, hustá, …

operace: sčítání, odčítání, násobení, …

formáty exportu: textový, binární, …

uživatelské rozhraní: konzole, ncurses, SDL, OpenGL (různé varianty), …

=== Další informace:
Pro parsování výrazu se může hodit Shunting-Yard algoritmus (http://en.wikipedia.org/wiki/Shunting-yard_algorithm).
Pro uložení do souboru můžete využít i binární formát, v takovém případě dejte uživateli na výběr.

== Specifikace

Maticová kalkulačka je implementována jako *konzolová aplikace*. Uživatel může vytvářet nové matice, mazat
provádět nad maticemi různé operace a
ukládat aktuální stav kalkulačky do souboru a později i stav kalkulačky opět nahrát.
Vstup z konzole bude vyžadován v postfix formátu (https://en.wikipedia.org/wiki/Reverse_Polish_notation[Reverse Polish Notation^]), konec vstupu bude potvrzen
novým řádkem -- `\n`. Zpracování výrazu bude probíhat nad polymorfním stromem AST.

Mezi podporované operace patří: sčítání, odčítání, násobení, transpozice, sloučení, oříznutí, nalezení inverze, výpočet determinantu,
určení hodnosti a GEM, pokud jsou tyto operace definovány.

Uživatel může zároveň vypsat všechny aktuálně uložené matice, vypsat konkrétní matici nebo zobrazit stručný manuál.
Příkazy (`load`, `exit`, `help`, ...) budou volány běžným způsobem (název příkazu + případný parametr), výpočty jako takové budou zadávány v postfix formátu.

=== Příklad běhu:
```
 >...
 $status
 > No user-defined matrices currently saved.
 $[[1, 2], [1, 3]] A =
 $A
 > | 1 2 |
 > | 1 3 |
 $[[1, 0, 0], [0, 1, 0], [0, 0, 1]] E =
 $[[2, 1, 5], [3, 2, 1], [7, 1, 0]] E +
 > | 3 1 5 |
 > | 3 3 2 |
 > | 7 1 1 |
 $A GEM
 > | 1 2 |
 > | 0 1 |
 $A
 > | 1 2 |
 > | 1 3 |
 $A GEM A =
 $A
 > | 1 2 |
 > | 0 1 |
 $save myMatricies.matx
 > Calculator saved successfully.
 $exit
 > Closing application.
```

== Polymorfismus

Polymorfismus bude implementován na úrovni abstraktní třídy CMatrix. Tato třída bude mít tři potomky - CDiagonalMatrix, CSparseMatrix a CDenseMatrix.
Implementace výpisu matice do konzole, či způsob uložení do souboru se bude lišit podle třídy.

Hlavním rozdílem mezi třídami je způsob uložení dat.
CDiagonalMatrix - diagonální matice - bude mít strukturu jednoduchého vektoru - diagonály. Ve třídě CSparseMatrix budou uloženy takové matice,
u nichž je počet nenulových prvků menší nebo roven počtu nižšího z počtu řádků/sloupců.
Řídké matice budou reprezentovány jako vektor trojic čísel (m_Row, m_Col, m_Val) - řádek, sloupec, hodnota. Nakonec husté matice jakožto objekty třídy CDenseMatrix
budou uloženy jako uloženy jako vektory m vektorů s n prvky, kde m je počet řádků a n počet sloupců.

Zároveň bude polymorfismus implementován na úrovni binárních i unárních operátorů. Základ nám bude tvořit abstraktní třída CBinaryOperator, resp. CUnaryOperator, která nám bude zastřešovat
konkrétní binární, resp. unární operátory. Tyto třídy obsahují abstraktní metodu
execute, která vykoná danou operaci. Výhodou je, že v argumentech můžeme využívat pouze reference na CMatrix, není nutné vytvářet různé třídy pro různé typy matix.

Konkrétní výpočet se bude realizovat nad polymorfním stromem AST, kde parent node bude obsahovat unární/binární operátor (výsledek operace je
vždy matice) a child nodes budou matice, nad kterými bude operace vykonána. Strom bude rekurzivně zpracováván odspodu. Př:

```
A = B * TR C - infix
C TR B * A = - postfix

       (=)
      /   \
    (*)   (A)
   /   \
 (B)    (TR)
          \
          (C)
```
Tedy bude muset existovat třida, která bude obsahovat pointery na operátory i matice. Tuto třídu nazveme CAbstractNode, jejíž členy nám budou tvořit AST. Tvorbu a zpracování tohoto
stromu nám obstarává třída CParser. CAbstractNode obsahuje metodu evaluate, která vyhodnotí hodnotu daného objektu. Pokud je objekt matice, vrací se přímo tato matice,
pokud je operátor, zavolá se se konkrétní operátor, jehož operandy jsou child nodes daného objektu, na které se opět zavolá metoda evaluate. To, jakého je daný node typu zjistíme podle toho,
který z pointerů je ne-nullový.